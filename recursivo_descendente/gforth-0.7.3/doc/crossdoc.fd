
make-doc image-header )

make-doc forthstart )

make-doc true -- f  ) core-ext
@code{Constant} -- @i{f} is a cell with all bits set.

make-doc false -- f  ) core-ext
@code{Constant} -- @i{f} is a cell with all bits clear.

make-doc cell -- u  ) gforth
@code{Constant} -- @code{1 cells}

make-doc float -- u  ) gforth
@code{Constant} -- the number of address units corresponding to a floating-point number.

make-doc bl -- c-char  ) core b-l
@i{c-char} is the character value for a space.

make-doc /line )

make-doc c/l )

make-doc l/s )

make-doc chars/block )

make-doc word-pno-size -- u  )

make-doc holdbuf )

make-doc holdbuf-end )

make-doc holdptr )

make-doc holdend )

make-doc pad-minsize -- u  )

make-doc def#tib )
default size of terminal input buffer. Default size is 1K

make-doc main-task )

make-doc udp -- a-addr  ) gforth
user area size

make-doc next-task )

make-doc prev-task )

make-doc save-task )

make-doc sp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the data stack pointer.
OBSOLETE alias of @code{sp0}

make-doc rp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the return stack pointer.
OBSOLETE alias of @code{rp0}

make-doc fp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the floating-point stack pointer.

make-doc lp0 -- a-addr  ) gforth
@code{User} variable -- initial value of the locals stack pointer.
OBSOLETE alias of @code{lp0}

make-doc handler )

make-doc backtrace-rp0 )

make-doc errorhandler )

make-doc "error )

make-doc current-input )

make-doc includefilename )

make-doc base -- a-addr  ) core
@code{User} variable -- @i{a-addr} is the address of a cell that
stores the number base used by default for number conversion during
input and output.  Don't store to @code{base}, use
@code{base-execute} instead.

make-doc dpl -- a-addr  ) gforth
@code{User} variable -- @i{a-addr} is the address of a cell that stores the 		
position of the decimal point in the most recent numeric conversion.
Initialised to -1. After the conversion of a number containing no
decimal point, @code{dpl} is -1. After the conversion of @code{2.} it holds
0. After the conversion of 234123.9 it contains 1, and so forth.

make-doc state -- a-addr  ) core,tools-ext
@code{User} variable -- @i{a-addr} is the address of a cell
containing the compilation state flag. 0 => interpreting, -1 =>
compiling.  A program shall not directly alter the value of
@code{state}. The following Standard words alter the value in
@code{state}: @code{:} (colon) @code{;} (semicolon) @code{abort}
@code{quit} @code{:noname} @code{[} (left-bracket) @code{]}
(right-bracket) @code{;code}. Don't use @code{state}! For an
alternative see @ref{Interpretation and Compilation Semantics}.

make-doc normal-dp )

make-doc dpp )

make-doc LastCFA )

make-doc Last )

make-doc max-name-length )

make-doc locals-size )

make-doc str= c-addr1 u1 c-addr2 u2 -- f  ) gforth

make-doc string-prefix? c-addr1 u1 c-addr2 u2 -- f  ) gforth
Is @var{c-addr2 u2} a prefix of @var{c-addr1 u1}?

make-doc str< c-addr1 u1 c-addr2 u2 -- f  ) gforth

make-doc NIL )

make-doc r@ -- w ; R: w -- w  ) core r-fetch

make-doc maxaligned addr1 -- addr2  ) gforth
@i{addr2} is the first address after @i{addr1} that satisfies
all alignment restrictions.
maxaligned"

make-doc cfaligned addr1 -- addr2  ) gforth
@i{addr2} is the first address after @i{addr1} that is aligned for
a code field (i.e., such that the corresponding body is maxaligned).

make-doc chars n1 -- n2  ) core
@i{n2} is the number of address units of @i{n1} chars.""

make-doc A! addr1 addr2 --  ) gforth

make-doc dictionary-end -- addr  )

make-doc usable-dictionary-end -- addr  )

make-doc unused -- u  ) core-ext
Return the amount of free space remaining (in address units) in
the region addressed by @code{here}.

make-doc in-dictionary? x -- f  )

make-doc dp -- addr  ) gforth

make-doc here -- addr  ) core
Return the address of the next free location in data space.

make-doc on a-addr --  ) gforth
Set the (value of the) variable  at @i{a-addr} to @code{true}.

make-doc off a-addr --  ) gforth
Set the (value of the) variable at @i{a-addr} to @code{false}.

make-doc dabs d -- ud  ) double d-abs

make-doc roll x0 x1 .. xn n -- x1 .. xn x0  ) core-ext

make-doc place addr len to --  ) gforth

make-doc bounds addr u -- addr+u addr  ) gforth
Given a memory block represented by starting address @i{addr}
and length @i{u} in aus, produce the end address @i{addr+u} and
the start address in the right order for @code{u+do} or
@code{?do}.

make-doc scan addr1 n1 char -- addr2 n2  ) gforth
skip all characters not equal to char

make-doc skip addr1 n1 char -- addr2 n2  ) gforth
skip all characters equal to char

make-doc digit? char -- digit true/ false  ) gforth

make-doc accumulate +d0 addr digit - +d1 addr  )

make-doc >number ud1 c-addr1 u1 -- ud2 c-addr2 u2  ) core to-number
Attempt to convert the character string @var{c-addr1 u1} to an
unsigned number in the current number base. The double
@var{ud1} accumulates the result of the conversion to form
@var{ud2}. Conversion continues, left-to-right, until the whole
string is converted or a character that is not convertable in
the current number base is encountered (including + or -). For
each convertable character, @var{ud1} is first multiplied by
the value in @code{BASE} and then incremented by the value
represented by the character. @var{c-addr2} is the location of
the first unconverted character (past the end of the string if
the whole string was converted). @var{u2} is the number of
unconverted characters in the string. Overflow is not detected.

make-doc s>d n -- d  ) core		s-to-d

make-doc ud/mod ud1 u2 -- urem udquot  ) gforth

make-doc lp@ -- addr  ) gforth	lp-fetch

make-doc catch x1 .. xn xt -- y1 .. ym 0 / z1 .. zn error  ) exception
@code{Executes} @i{xt}.  If execution returns normally,
@code{catch} pushes 0 on the stack.  If execution returns through
@code{throw}, all the stacks are reset to the depth on entry to
@code{catch}, and the TOS (the @i{xt} position) is replaced with
the throw code.

make-doc throw y1 .. ym nerror -- y1 .. ym / z1 .. zn error  ) exception
If @i{nerror} is 0, drop it and continue.  Otherwise, transfer
control to the next dynamically enclosing exception handler, reset
the stacks accordingly, and push @i{nerror}.

make-doc c(abort") c-addr --  )

make-doc (ABORT") )

make-doc abort ?? -- ??  ) core,exception-ext
@code{-1 throw}.

make-doc ?stack ?? -- ??  ) gforth

make-doc depth -- +n  ) core depth
@var{+n} is the number of values that were on the data stack before
@var{+n} itself was placed on the stack.

make-doc clearstack ... --  ) gforth clear-stack
remove and discard all/any items from the data stack.

make-doc clearstacks ... --  ) gforth clear-stacks
empty data and FP stack

make-doc "lit -- addr  )

make-doc decimal --  ) core
Set @code{base} to &10 (decimal).  Don't use @code{hex}, use
@code{base-execute} instead.

make-doc hex --  ) core-ext
Set @code{base} to &16 (hexadecimal).  Don't use @code{hex},
use @code{base-execute} instead.

make-doc outfile-id -- file-id  ) gforth

make-doc infile-id -- file-id  ) gforth

make-doc (type) c-addr u --  ) gforth

make-doc (emit) c --  ) gforth

make-doc (key) -- c  ) gforth

make-doc (key?) -- flag  ) gforth

make-doc type c-addr u --  ) core
If @var{u}>0, display @var{u} characters from a string starting
with the character stored at @var{c-addr}.

make-doc emit c --  ) core
Display the character associated with character value c.

make-doc key -- char  ) core
Receive (but do not display) one character, @var{char}.

make-doc key? -- flag  ) facility key-question
Determine whether a character is available. If a character is
available, @var{flag} is true; the next call to @code{key} will
yield the character. Once @code{key?} returns true, subsequent
calls to @code{key?} before calling @code{key} or @code{ekey} will
also return true.

make-doc (.") )

make-doc (S") )

make-doc #eof -- c  ) gforth

make-doc #bell -- c  ) gforth

make-doc #bs -- c  ) gforth

make-doc #tab -- c  ) gforth

make-doc #del -- c  ) gforth

make-doc #cr -- c  ) gforth

make-doc #ff -- c  ) gforth

make-doc #lf -- c  ) gforth

make-doc bell )

make-doc cr --  ) core c-r
Output a newline (of the favourite kind of the host OS).  Note
that due to the way the Forth command line interpreter inserts
newlines, the preferred way to use @code{cr} is at the start
of a piece of text; e.g., @code{cr ." hello, world"}.

make-doc space --  ) core
Display one space.

make-doc spaces u --  ) core
Display @var{n} spaces. 

make-doc backspaces )

make-doc pad -- c-addr  ) core-ext
@var{c-addr} is the address of a transient region that can be
used as temporary data storage. At least 84 characters of space
is available.

make-doc hold char --  ) core
Used within @code{<#} and @code{#>}. Append the character
@var{char} to the pictured numeric output string.

make-doc <# --  ) core	less-number-sign
Initialise/clear the pictured numeric output string.

make-doc #> xd -- addr u  ) core	number-sign-greater
Complete the pictured numeric output string by discarding
@var{xd} and returning @var{addr u}; the address and length of
the formatted string. A Standard program may modify characters
within the string.

make-doc <<# --  ) gforth	less-less-number-sign
Start a hold area that ends with @code{#>>}. Can be nested in
each other and in @code{<#}.  Note: if you do not match up the
@code{<<#}s with @code{#>>}s, you will eventually run out of
hold area; you can reset the hold area to empty with @code{<#}.

make-doc #>> --  ) gforth	number-sign-greater-greater
Release the hold area started with @code{<<#}.

make-doc sign n --  ) core
Used within @code{<#} and @code{#>}. If @var{n} (a @var{single}
number) is negative, append the display code for a minus sign
to the pictured numeric output string. Since the string is
built up ``backwards'' this is usually used immediately prior
to @code{#>}, as shown in the examples below.

make-doc # ud1 -- ud2  ) core		number-sign
Used within @code{<#} and @code{#>}. Add the next
least-significant digit to the pictured numeric output
string. This is achieved by dividing @var{ud1} by the number in
@code{base} to leave quotient @var{ud2} and remainder @var{n};
@var{n} is converted to the appropriate display code (eg ASCII
code) and appended to the string. If the number has been fully
converted, @var{ud1} will be 0 and @code{#} will append a ``0''
to the string.

make-doc #s ud -- 0 0  ) core	number-sign-s
Used within @code{<#} and @code{#>}. Convert all remaining digits
using the same algorithm as for @code{#}. @code{#s} will convert
at least one digit. Therefore, if @var{ud} is 0, @code{#s} will append
a ``0'' to the pictured numeric output string.

make-doc d.r d n --  ) double	d-dot-r
Display @var{d} right-aligned in a field @var{n} characters wide. If more than
@var{n} characters are needed to display the number, all digits are displayed.
If appropriate, @var{n} must include a character for a leading ``-''.

make-doc ud.r ud n --  ) gforth	u-d-dot-r
Display @var{ud} right-aligned in a field @var{n} characters wide. If more than
@var{n} characters are needed to display the number, all digits are displayed.

make-doc .r n1 n2 --  ) core-ext	dot-r
Display @var{n1} right-aligned in a field @var{n2} characters wide. If more than
@var{n2} characters are needed to display the number, all digits are displayed.
If appropriate, @var{n2} must include a character for a leading ``-''.

make-doc u.r u n --  ) core-ext	u-dot-r
Display @var{u} right-aligned in a field @var{n} characters wide. If more than
@var{n} characters are needed to display the number, all digits are displayed.

make-doc d. d --  ) double	d-dot
Display (the signed double number) @var{d} in free-format. followed by a space.

make-doc ud. ud --  ) gforth	u-d-dot
Display (the signed double number) @var{ud} in free-format, followed by a space.

make-doc . n --  ) core	dot
Display (the signed single number) @var{n} in free-format, followed by a space.

make-doc u. u --  ) core	u-dot
Display (the unsigned single number) @var{u} in free-format, followed by a space.

make-doc ErrLink )

make-doc >stderr --  )

make-doc .error n --  )

make-doc version-string )

make-doc (word) addr1 n1 char -- addr2 n2  )

make-doc sword char -- addr len  ) gforth-obsolete s-word
Parses like @code{word}, but the output is like @code{parse} output.
@xref{core-idef}.

make-doc word char "<chars>ccc<char>-- c-addr  ) core
Skip leading delimiters. Parse @i{ccc}, delimited by
@i{char}, in the parse area. @i{c-addr} is the address of a
transient region containing the parsed string in
counted-string format. If the parse area was empty or
contained no characters other than delimiters, the resulting
string has zero length. A program may replace characters within
the counted string. OBSOLESCENT: the counted string has a
trailing space that is not included in its length.

make-doc parse char "ccc<char>" -- c-addr u  ) core-ext
Parse @i{ccc}, delimited by @i{char}, in the parse
area. @i{c-addr u} specifies the parsed string within the
parse area. If the parse area was empty, @i{u} is 0.

make-doc (name) -- c-addr count  ) gforth

make-doc name-too-short? c-addr u -- c-addr u  )

make-doc name-too-long? c-addr u -- c-addr u  )

make-doc bases )

make-doc getbase addr u -- addr' u'  )

make-doc sign? addr u -- addr1 u1 flag  )

make-doc ?dnegate d1 f -- d2  )

make-doc s'>unumber? addr u -- ud flag  )

make-doc s>unumber? c-addr u -- ud flag  ) gforth
converts string c-addr u into ud, flag indicates success

make-doc s>number? addr u -- d f  ) gforth
converts string addr u into d, flag indicates success

make-doc s>number addr len -- d  )

make-doc snumber? c-addr u -- 0 / n -1 / d 0>  )

make-doc number? string -- string 0 / n -1 / d 0>  )

make-doc number string -- d  )

make-doc ( compilation 'ccc<close-paren>' -- ; run-time --  ) thisone- core,file	paren
** this will not get annotated. The alias in glocals.fs will instead **
It does not work to use "wordset-" prefix since this file is glossed
by cross.fs which doesn't have the same functionalty as makedoc.fs

make-doc \ compilation 'ccc<newline>' -- ; run-time --  ) thisone- core-ext,block-ext backslash
** this will not get annotated. The alias in glocals.fs will instead ** 
It does not work to use "wordset-" prefix since this file is glossed
by cross.fs which doesn't have the same functionalty as makedoc.fs

make-doc \G compilation 'ccc<newline>' -- ; run-time --  ) gforth backslash-gee
Equivalent to @code{\} but used as a tag to annotate definition
comments into documentation.

make-doc find-method c_addr u wid -- nt  )

make-doc reveal-method nt wid --  ) used by dofield:, must be field

make-doc rehash-method wid --  ) re-initializes a "search-data" (hashtables)

make-doc hash-method wid --  ) initializes ""

make-doc wordlist-map-struct )

make-doc wordlist-map )

make-doc wordlist-idfor WORDS etc. )

make-doc wordlist-link )

make-doc wordlist-extendeg bucket offset )

make-doc wordlist-struct )

make-doc f83find addr len wordlist -- nt / false  )

make-doc initvoc wid --  )

make-doc f83search -- wordlist-map  )

make-doc forth-wordlist )

make-doc lookup )

make-doc current -- addr  ) gforth
@code{Variable} -- holds the @i{wid} of the compilation word list.

make-doc voclink )

make-doc context -- addr  ) gforth
@code{context} @code{@@} is the @i{wid} of the word list at the
top of the search order.

make-doc (search-wordlist) addr count wid -- nt | false  )

make-doc search-wordlist c-addr count wid -- 0 | xt +-1  ) search
Search the word list identified by @i{wid} for the definition
named by the string at @i{c-addr count}.  If the definition is
not found, return 0. If the definition is found return 1 (if
the definition is immediate) or -1 (if the definition is not
immediate) together with the @i{xt}.  In Gforth, the @i{xt}
returned represents the interpretation semantics.  ANS Forth
does not specify clearly what @i{xt} represents.

make-doc find-name c-addr u -- nt | 0  ) gforth
Find the name @i{c-addr u} in the current search
order. Return its @i{nt}, if found, otherwise 0.

make-doc alias-mask )

make-doc immediate-mask )

make-doc restrict-mask )

make-doc lcount-mask )

make-doc flag-sign f -- 1|-1  )

make-doc ticking-compile-only-error ... --  )

make-doc compile-only-error ... --  )

make-doc (cfa>int) cfa -- xt  )

make-doc (x>int) cfa w -- xt  )

make-doc name>string nt -- addr count  ) gforth     name-to-string
@i{addr count} is the name of the word represented by @i{nt}.

make-doc ((name>)) nfa -- cfa  )

make-doc (name>x) nfa -- cfa w  )

make-doc name>int nt -- xt  ) gforth name-to-int
@i{xt} represents the interpretation semantics of the word
@i{nt}. If @i{nt} has no interpretation semantics (i.e. is
@code{compile-only}), @i{xt} is the execution token for
@code{ticking-compile-only-error}, which performs @code{-2048 throw}.

make-doc name?int nt -- xt  ) gforth name-question-int
Like @code{name>int}, but perform @code{-2048 throw} if @i{nt}
has no interpretation semantics.

make-doc (name>comp) nt -- w +-1  ) gforth
@i{w xt} is the compilation token for the word @i{nt}.

make-doc (name>intn) nfa -- xt +-1  )

make-doc ??? )

make-doc head? addr -- f  )
heuristic check whether addr is a name token; may deliver false
positives; addr must be a valid address; returns 1 for
particularly unsafe positives

make-doc >head-noprim cfa -- nt  ) gforth  to-head-noprim

make-doc >body xt -- a_addr  ) core to-body
Get the address of the body of the word represented by @i{xt} (the
address of the word's data field).

make-doc body> xt -- a_addr  )

make-doc >code-address xt -- c_addr  ) gforth
@i{c-addr} is the code address of the word @i{xt}.

make-doc >does-code xt -- a_addr  ) gforth
If @i{xt} is the execution token of a child of a @code{DOES>} word,
@i{a-addr} is the start of the Forth code after the @code{DOES>};
Otherwise @i{a-addr} is 0.

make-doc flash! )

make-doc flashc! )

make-doc code-address! c_addr xt --  ) gforth
Create a code field with code address @i{c-addr} at @i{xt}.

make-doc does-code! a_addr xt --  ) gforth
Create a code field at @i{xt} for a child of a @code{DOES>}-word;
@i{a-addr} is the start of the Forth code after @code{DOES>}.

make-doc does-handler! a_addr --  ) gforth
Create a @code{DOES>}-handler at address @i{a-addr}. Normally,
@i{a-addr} points just behind a @code{DOES>}.

make-doc /does-handler -- n  ) gforth
The size of a @code{DOES>}-handler (includes possible padding).

make-doc sfind c-addr u -- 0 / xt +-1   ) gforth-obsolete

make-doc find c-addr -- xt +-1 | c-addr 0  ) core,search
Search all word lists in the current search order for the
definition named by the counted string at @i{c-addr}.  If the
definition is not found, return 0. If the definition is found
return 1 (if the definition has non-default compilation
semantics) or -1 (if the definition has default compilation
semantics).  The @i{xt} returned in interpret state represents
the interpretation semantics.  The @i{xt} returned in compile
state represented either the compilation semantics (for
non-default compilation semantics) or the run-time semantics
that the compilation semantics would @code{compile,} (for
default compilation semantics).  The ANS Forth standard does
not specify clearly what the returned @i{xt} represents (and
also talks about immediacy instead of non-default compilation
semantics), so this word is questionable in portable programs.
If non-portability is ok, @code{find-name} and friends are
better (@pxref{Name token}).

make-doc (') "name" -- nt  ) gforth

make-doc ' "name" -- xt  ) core	tick
@i{xt} represents @i{name}'s interpretation
semantics. Perform @code{-14 throw} if the word has no
interpretation semantics.

make-doc parser1 c-addr u -- ... xt )

make-doc parser c-addr u -- ...  )

make-doc parse-name "name" -- c-addr u  ) gforth
Get the next word from the input buffer

make-doc parse-word -- c-addr u  ) gforth-obsolete
old name for @code{parse-name}

make-doc name -- c-addr u  ) gforth-obsolete
old name for @code{parse-name}

make-doc compiler-notfound1 c-addr count -- ... xt  )

make-doc interpreter-notfound1 c-addr count -- ... xt  )

make-doc no.extensions addr u --  )

make-doc before-word --  ) gforth

make-doc interpret1 ... -- ...  )

make-doc interpret ?? -- ??  ) gforth

make-doc interpreter1 c-addr u -- ... xt  )

make-doc save-mem addr1 u -- addr2 u  ) gforth
copy a memory block into a newly allocated region in the heap

make-doc free-mem-var addr --  )

make-doc extend-mem addr1 u1 u -- addr addr2 u2  )

make-doc 'quit )

make-doc .status )

make-doc prompt )

make-doc (quit) --  )

make-doc max-errors )

make-doc /error )

make-doc error-stack )

make-doc error> --  c-addr1 u1 c-addr2 u2 line# [addr u]  )

make-doc >error c-addr1 u1 c-addr2 u2 line# [addr u] --  )

make-doc input-error-data -- c-addr1 u1 c-addr2 u2 line# [addr u]  )

make-doc dec. n --  ) gforth
Display @i{n} as a signed decimal number, followed by a space.

make-doc dec.r u n --  ) gforth
Display @i{u} as a unsigned decimal number in a field @i{n}
characters wide.

make-doc hex. u --  ) gforth
Display @i{u} as an unsigned hex number, prefixed with a "$" and
followed by a space.

make-doc -trailing c_addr u1 -- c_addr u2  ) string dash-trailing
Adjust the string specified by @i{c-addr, u1} to remove all
trailing spaces. @i{u2} is the length of the modified string.

make-doc DoError )

make-doc dobacktrace --  )

make-doc .error-string throw-code --  )

make-doc umin u1 u2 -- u  )

make-doc mark-start )

make-doc mark-end )

make-doc part-type addr1 u1 u -- addr2 u2  )

make-doc .error-line c-addr1 u1 c-addr2 u2 --  )

make-doc .error-frame throwcode addr1 u1 addr2 u2 n2 [addr3 u3] -- throwcode  )

make-doc (DoError) throw-code --  )

make-doc quit ?? -- ??  ) core
Empty the return stack, make the user input device
the input source, enter interpret state and start
the text interpreter.

make-doc (bootmessage) --  )

make-doc bootmessage --  ) gforth
Hook (deferred word) executed right after interpreting the OS
command-line arguments.  Normally prints the Gforth startup
message.

make-doc process-args )

make-doc 'cold --  ) gforth  tick-cold
Hook (deferred word) for things to do right before interpreting the
OS command-line arguments.  Normally does some initializations that
you also want to perform.

make-doc cold --  ) gforth

make-doc boot path n **argv argc --  )

make-doc bye --  ) tools-ext

make-doc allot n --  ) core
Reserve @i{n} address units of data space without
initialization. @i{n} is a signed number, passing a negative
@i{n} releases memory.  In ANS Forth you can only deallocate
memory from the current contiguous region in this way.  In
Gforth you can deallocate anything in this way but named words.
The system does not check this restriction.

make-doc c, c --  ) core c-comma
Reserve data space for one char and store @i{c} in the space.

make-doc , w --  ) core comma
Reserve data space for one cell and store @i{w} in the space.

make-doc 2, w1 w2 --  ) gforth
Reserve data space for two cells and store the double @i{w1
w2} there, @i{w2} first (lower address).

make-doc align --  ) core
If the data-space pointer is not aligned, reserve enough space to align it.

make-doc falign --  ) float f-align
If the data-space pointer is not float-aligned, reserve
enough space to align it.

make-doc maxalign --  ) gforth
Align data-space pointer for all alignment requirements.

make-doc cfalign --  ) gforth
Align data-space pointer for code field requirements (i.e., such
that the corresponding body is maxaligned).

make-doc A, addr --  ) gforth

make-doc const )

make-doc (header) )

make-doc header --  ) gforth

make-doc string, c-addr u --  ) gforth
puts down string as cstring

make-doc longstring, c-addr u --  ) gforth
puts down string as longcstring

make-doc header, c-addr u --  ) gforth

make-doc input-stream-header "name" --  )

make-doc input-stream --  ) general
switches back to getting the name from the input stream ;

make-doc nextname-string )

make-doc nextname-header --  )

make-doc nextname c-addr u --  ) gforth
The next defined word will have the name @var{c-addr u}; the
defining word will leave the input stream alone.

make-doc noname-header --  )

make-doc noname --  ) gforth
The next defined word will be anonymous. The defining word will
leave the input stream alone. The xt of the defined word will
be given by @code{latestxt}.

make-doc latestxt -- xt  ) gforth
@i{xt} is the execution token of the last word defined.

make-doc lastxt )
old name for @code{latestxt}.

make-doc latest -- nt  ) gforth
@var{nt} is the name token of the last word defined; it is 0 if the
last word has no name.

make-doc Literal compilation n -- ; run-time -- n  ) core
Compilation semantics: compile the run-time semantics.@*
Run-time Semantics: push @i{n}.@*
Interpretation semantics: undefined.

make-doc 2Literal compilation w1 w2 -- ; run-time  -- w1 w2  ) double two-literal
Compile appropriate code such that, at run-time, @i{w1 w2} are
placed on the stack. Interpretation semantics are undefined.

make-doc ALiteral compilation addr -- ; run-time -- addr  ) gforth

make-doc char@ addr u -- char addr' u'  )

make-doc char '<spaces>ccc' -- c  ) core
Skip leading spaces. Parse the string @i{ccc} and return @i{c}, the
display code representing the first character of @i{ccc}.

make-doc [Char] compilation '<spaces>ccc' -- ; run-time -- c  ) core bracket-char
Compilation: skip leading spaces. Parse the string
@i{ccc}. Run-time: return @i{c}, the display code
representing the first character of @i{ccc}.  Interpretation
semantics for this word are undefined.

make-doc cfa, code-address --  ) gforth	cfa-comma

make-doc compile, xt --  ) core-ext	compile-comma
 Compile the word represented by the execution token @i{xt}
 into the current definition.

make-doc basic-block-end --  )

make-doc peephole-compile, xt --  )

make-doc compile-to-prims, xt --  )
compile xt to use primitives (and their peephole optimization)
instead of ","-ing the xt.

make-doc !does addr --  ) gforth	store-does

make-doc (does>) R: addr --  )

make-doc (does>2) addr --  )

make-doc dodoes, --  )

make-doc (compile) --  ) gforth-obsolete: dummy

make-doc name>comp nt -- w xt  ) gforth name-to-comp
@i{w xt} is the compilation token for the word @i{nt}.

make-doc [(')] compilation "name" -- ; run-time -- nt  ) gforth bracket-paren-tick

make-doc ['] compilation. "name" -- ; run-time. -- xt  ) core      bracket-tick
@i{xt} represents @i{name}'s interpretation
semantics. Perform @code{-14 throw} if the word has no
interpretation semantics.

make-doc COMP' "name" -- w xt  ) gforth  comp-tick
Compilation token @i{w xt} represents @i{name}'s compilation semantics.

make-doc [COMP'] compilation "name" -- ; run-time -- w xt  ) gforth bracket-comp-tick
Compilation token @i{w xt} represents @i{name}'s compilation semantics.

make-doc postpone, w xt --  ) gforth	postpone-comma
Compile the compilation semantics represented by the
compilation token @i{w xt}.

make-doc postpone "name" --  ) core
Compiles the compilation semantics of @i{name}.

make-doc recurse compilation -- ; run-time ?? -- ??  ) core
Call the current definition.

make-doc compiler1 c-addr u -- ... xt  )

make-doc [ --  )  core	left-bracket
Enter interpretation state. Immediate word.

make-doc ] --  ) core	right-bracket
Enter compilation state.

make-doc S, addr u --  )

make-doc mem, addr u --  )

make-doc ," "string"<"> --  )

make-doc cset bmask c-addr --  )

make-doc creset bmask c-addr --  )

make-doc ctoggle bmask c-addr --  )

make-doc lastflags -- c-addr  )

make-doc immediate --  ) core
Make the compilation semantics of a word be to @code{execute}
the execution semantics.

make-doc restrict --  ) gforth
A synonym for @code{compile-only}

make-doc compile-only --  ) gforth
Remove the interpretation semantics of a word.

make-doc Alias xt "name" --  ) gforth

make-doc Create "name" --  ) core

make-doc Variable "name" --  ) core

make-doc AVariable "name" --  ) gforth

make-doc 2Variable "name" --  ) double two-variable

make-doc uallot n --  ) gforth

make-doc User "name" --  ) gforth

make-doc AUser "name" --  ) gforth

make-doc (Constant) )

make-doc (Value) )

make-doc Constant w "name" --  ) core
Define a constant @i{name} with value @i{w}.
 
@i{name} execution: @i{-- w}

make-doc AConstant addr "name" --  ) gforth

make-doc Value w "name" --  ) core-ext

make-doc AValue w "name" --  ) core-ext

make-doc 2Constant w1 w2 "name" --  ) double two-constant

make-doc (Field) )

make-doc interpret/compile-int )

make-doc interpret/compile-comp )

make-doc interpret/compile-struct )

make-doc interpret/compile: interp-xt comp-xt "name" --  ) gforth

make-doc defer-default --  )

make-doc Defer "name" --  ) gforth
Define a deferred word @i{name}; its execution semantics can be
set with @code{defer!} or @code{is} (and they have to, before first
executing @i{name}.

make-doc defer@ xt-deferred -- xt  ) gforth defer-fetch
@i{xt} represents the word currently associated with the deferred
word @i{xt-deferred}.

make-doc defers compilation "name" -- ; run-time ... -- ...  ) gforth
Compiles the present contents of the deferred word @i{name}
into the current definition.  I.e., this produces static
binding as if @i{name} was not deferred.

make-doc DOES> compilation colon-sys1 -- colon-sys2 ; run-time nest-sys --  ) core        does

make-doc defer! xt xt-deferred --  ) gforth  defer-store
Changes the @code{defer}red word @var{xt-deferred} to execute @var{xt}.

make-doc <IS> "name" xt --  ) gforth
Changes the @code{defer}red word @var{name} to execute @var{xt}.

make-doc [IS] compilation "name" -- ; run-time xt --  ) gforth bracket-is
At run-time, changes the @code{defer}red word @var{name} to
execute @var{xt}.

make-doc IS compilation/interpretation "name-deferred" -- ; run-time xt --  ) gforth
Changes the @code{defer}red word @var{name} to execute @var{xt}.
Its compilation semantics parses at compile time.

make-doc TO w "name" --  ) core-ext

make-doc interpret/compile? xt -- flag  )

make-doc :-hook sys1 -- sys2  )

make-doc ;-hook sys2 -- sys1  )

make-doc defstart )

make-doc (:noname) -- colon-sys  )

make-doc : "name" -- colon-sys  ) core	colon

make-doc :noname -- xt colon-sys  ) core-ext	colon-no-name

make-doc ; compilation colon-sys -- ; run-time nest-sys  ) core	semicolon

make-doc last? -- false / nfa nfa  )

make-doc warnings -- addr  ) gforth

make-doc (reveal) nt wid --  )

make-doc check-shadow addr count wid --  )
prints a warning if the string is already present in the wordlist

make-doc reveal --  ) gforth

make-doc rehash wid --  )

make-doc recursive compilation -- ; run-time --  ) gforth
Make the current definition visible, enabling it to call itself
recursively.

make-doc (ins) max span addr pos1 key -- max span addr pos2  )

make-doc (bs) max span addr pos1 -- max span addr pos2 flag  )

make-doc (ret) max span addr pos1 -- max span addr pos2 flag  )

make-doc ctrlkeys )

make-doc insert-char )

make-doc everychar )

make-doc everyline )

make-doc decode max span addr pos1 key -- max span addr pos2 flag  )

make-doc edit-line c-addr n1 n2 -- n3  ) gforth
edit the string with length @var{n2} in the buffer @var{c-addr
n1}, like @code{accept}.

make-doc accept c-addr +n1 -- +n2  ) core
Get a string of up to @var{n1} characters from the user input
device and store it at @var{c-addr}.  @var{n2} is the length of
the received string. The user indicates the end by pressing
@key{RET}.  Gforth supports all the editing functions available
on the Forth command line (including history and word
completion) in @code{accept}.

make-doc input-method m "name" -- m'  )

make-doc input-var v size "name" -- v'  )

make-doc source -- addr u  ) core source
Return address @i{addr} and length @i{u} of the current input
buffer

make-doc refill -- flag  ) core-ext,block-ext,file-ext
Attempt to fill the input buffer from the input source.  When
the input source is the user input device, attempt to receive
input into the terminal input device. If successful, make the
result the input buffer, set @code{>IN} to 0 and return true;
otherwise return false. When the input source is a block, add 1
to the value of @code{BLK} to make the next block the input
source and current input buffer, and set @code{>IN} to 0;
return true if the new value of @code{BLK} is a valid block
number, false otherwise. When the input source is a text file,
attempt to read the next line from the file. If successful,
make the result the current input buffer, set @code{>IN} to 0
and return true; otherwise, return false.  A successful result
includes receipt of a line containing 0 characters.

make-doc source-id -- 0 | -1 | fileid  ) core-ext,file source-i-d
Return 0 (the input source is the user input device), -1 (the
input source is a string being processed by @code{evaluate}) or
a @i{fileid} (the input source is the file specified by
@i{fileid}).

make-doc (save-input) -- x1 .. xn n  ) gforth

make-doc (restore-input) x1 .. xn n --  ) gforth

make-doc >in -- addr  ) core to-in
@code{input-var} variable -- @i{a-addr} is the address of a
cell containing the char offset from the start of the input
buffer to the start of the parse area.

make-doc input-lexeme -- a-addr  ) gforth-internal
@code{input-var} variable -- @i{a-addr} is the address of two
cells containing the string (in c-addr u form) parsed with
@code{parse}, @code{parse-name} or @code{word}.  If you do your
own parsing, you can set it with @code{input-lexeme!}.

make-doc #tib -- addr  ) core-ext-obsolescent number-t-i-b
@code{input-var} variable -- @i{a-addr} is the address of a
cell containing the number of characters in the terminal input
buffer. OBSOLESCENT: @code{source} superceeds the function of
this word.

make-doc max#tib -- addr  ) gforth max-number-t-i-b
@code{input-var} variable -- This cell contains the maximum
size of the current tib.

make-doc old-input -- addr  ) gforth
@code{input-var} variable -- This cell contains the pointer to
the previous input buffer

make-doc loadline -- addr  ) gforth
@code{input-var} variable -- This cell contains the line that's
currently loaded from

make-doc loadfile -- addr  ) gforth
@code{input-var} variable -- This cell contains the file the
input buffer is associated with (0 if none)

make-doc blk -- addr  ) block b-l-k
@code{input-var} variable -- This cell contains the current
block number

make-doc #fill-bytes -- addr  ) gforth
@code{input-var} variable -- number of bytes read via
(read-line) by the last refill

make-doc loadfilename -- addr  ) gforth
@code{input-var} variable -- addr u describes name of currently
interpreted input (file name or somesuch)

make-doc tib -- addr  ) core-ext-obsolescent t-i-b

make-doc tib+ )

make-doc input-lexeme! c-addr u --  )

make-doc input-start-line --  )

make-doc terminal-input )

make-doc evaluate-input )

make-doc read-line c_addr u1 wfileid -- u2 flag wior  ) file

make-doc file-input )

make-doc new-tib method n --  ) gforth
Create a new entry of the tib stack, size @i{n}, method table
@i{method}.

make-doc expand-tib n --  )

make-doc push-file --  ) gforth
Create a new file input buffer

make-doc pop-file throw-code -- throw-code  ) gforth
pop and free the current top input buffer

make-doc save-input -- x1 .. xn n  ) core-ext
The @i{n} entries @i{xn - x1} describe the current state of the
input source specification, in some platform-dependent way that can
be used by @code{restore-input}.

make-doc restore-input x1 .. xn n -- flag  ) core-ext
Attempt to restore the input source specification to the state
described by the @i{n} entries @i{xn - x1}. @i{flag} is true if
the restore fails.  In Gforth with the new input code, it fails
only with a flag that can be used to throw again; it is also
possible to save and restore between different active input
streams. Note that closing the input streams must happen in the
reverse order as they have been opened, but in between
everything is allowed.

make-doc create-input --  )
create a new terminal input

make-doc execute-parsing-wrapper ... addr1 u1 xt addr2 u2 -- ...  ) gforth-internal

make-doc execute-parsing ... addr u xt -- ...  ) gforth
Make @i{addr u} the current input source, execute @i{xt @code{(
... -- ... )}}, then restore the previous input source.

make-doc evaluate ... addr u -- ...  ) core,block
Save the current input source specification. Store @code{-1} in
@code{source-id} and @code{0} in @code{blk}. Set @code{>IN} to
@code{0} and make the string @i{c-addr u} the input source and
input buffer. Interpret. When the parse area is empty, restore the
input source specification.

make-doc clear-tibstack --  ) gforth
clears the tibstack; if there is none, create the bottom entry:
the terminal input buffer.

make-doc query --  ) core-ext-obsolescent
Make the user input device the input source. Receive input into
the Terminal Input Buffer. Set @code{>IN} to zero. OBSOLESCENT:
superceeded by @code{accept}.

make-doc line-end-hook --  ) gforth
called at every end-of-line when text-interpreting from a file    

make-doc read-loop i*x -- j*x  ) gforth
refill and interpret a file until EOF

make-doc execute-parsing-named-file i*x wfileid filename-addr filename-u xt -- j*x  )

make-doc execute-parsing-file i*x fileid xt -- j*x  ) gforth
Make @i{fileid} the current input source, execute @i{xt @code{( i*x
-- j*x )}}, then restore the previous input source.

make-doc include-file i*x wfileid -- j*x  ) file
Interpret (process using the text interpreter) the contents of
the file @var{wfileid}.

make-doc license --  ) gforth

make-doc xemit xc --  ) xchar-ext
Prints an xchar on the terminal.

make-doc xkey -- xc  ) xchar-ext
Reads an xchar from the terminal. This will discard all input
events up to the completion of the xchar.

make-doc xchar+ xc-addr1 -- xc-addr2  ) xchar-ext
Adds the size of the xchar stored at @var{xc-addr1} to this address,
giving @var{xc-addr2}.

make-doc xchar- xc-addr1 -- xc-addr2  ) xchar-ext
Goes backward from @var{xc_addr1} until it finds an xchar so that
the size of this xchar added to @var{xc_addr2} gives
@var{xc_addr1}.

make-doc +x/string xc-addr1 u1 -- xc-addr2 u2  ) xchar	plus-x-slash-string
Step forward by one xchar in the buffer defined by address
@var{xc-addr1}, size @var{u1} pchars. @var{xc-addr2} is the address
and u2 the size in pchars of the remaining buffer after stepping
over the first xchar in the buffer.

make-doc x\string- xc-addr1 u1 -- xc-addr1 u2  ) xchar	x-back-string-minus
Step backward by one xchar in the buffer defined by address
@var{xc-addr1} and size @var{u1} in pchars, starting at the end of
the buffer. @var{xc-addr1} is the address and @var{u2} the size in
pchars of the remaining buffer after stepping backward over the
last xchar in the buffer.

make-doc xc@ xc-addr -- xc  ) xchar-ext	xc-fetch
Fetchs the xchar @var{xc} at @var{xc-addr1}.

make-doc xc!+? xc xc-addr1 u1 -- xc-addr2 u2 f  ) xchar-ext	xc-store-plus-query
Stores the xchar @var{xc} into the buffer starting at address
@var{xc-addr1}, @var{u1} pchars large. @var{xc-addr2} points to the
first memory location after @var{xc}, @var{u2} is the remaining
size of the buffer. If the xchar @var{xc} did fit into the buffer,
@var{f} is true, otherwise @var{f} is false, and @var{xc-addr2}
@var{u2} equal @var{xc-addr1} @var{u1}. XC!+?  is safe for buffer
overflows, and therefore preferred over XC!+.

make-doc xc@+ xc-addr1 -- xc-addr2 xc  ) xchar-ext	xc-fetch-plus
Fetchs the xchar @var{xc} at @var{xc-addr1}. @var{xc-addr2} points
to the first memory location after @var{xc}.

make-doc xc-size xc -- u  ) xchar-ext
Computes the memory size of the xchar @var{xc} in pchars.

make-doc x-size xc-addr u1 -- u2  ) xchar
Computes the memory size of the first xchar stored at @var{xc-addr}
in pchars.

make-doc x-width xc-addr u -- n  ) xchar-ext
@var{n} is the number of monospace ASCII pchars that take the same
space to display as the the xchar string starting at @var{xc-addr},
using @var{u} pchars; assuming a monospaced display font,
i.e. pchar width is always an integer multiple of the width of an
ASCII pchar.

make-doc -trailing-garbage xc-addr u1 -- addr u2  ) xchar-ext
Examine the last XCHAR in the buffer @var{xc-addr} @var{u1}---if
the encoding is correct and it repesents a full pchar, @var{u2}
equals @var{u1}, otherwise, @var{u2} represents the string without
the last (garbled) xchar.

make-doc x@+/string xc-addr1 u1 -- xc-addr2 u2 xc  )

make-doc xhold xc --  )
Put xc into the pictured numeric output

make-doc char- c-addr1 -- c-addr2  )

make-doc +string c-addr1 u1 -- c-addr2 u2  )

make-doc string- c-addr1 u1 -- c-addr1 u2  )

make-doc c!+? c c-addr1 u1 -- c-addr2 u2 f  )

make-doc c-size c -- 1  )

make-doc set-encoding-fixed-width --  )

make-doc cstring>sstring cstring -- addr n  ) gforth	cstring-to-sstring

make-doc arg u -- addr count  ) gforth
Return the string for the @i{u}th command-line argument; returns
@code{0 0} if the access is beyond the last argument.  @code{0 arg}
is the program name with which you started Gforth.  The next
unprocessed argument is always @code{1 arg}, the one after that is
@code{2 arg} etc.  All arguments already processed by the system
are deleted.  After you have processed an argument, you can delete
it with @code{shift-args}.

make-doc #! --  ) gforth   hash-bang
An alias for @code{\}

make-doc pathstring )

make-doc pathdirs )

make-doc argv -- addr  ) gforth
@code{Variable} -- a pointer to a vector of pointers to the
command-line arguments (including the command-name). Each argument
is represented as a C-style zero-terminated string.  Changed by
@code{next-arg} and @code{shift-args}.

make-doc argc -- addr  ) gforth
@code{Variable} -- the number of command-line arguments (including
the command name).  Changed by @code{next-arg} and @code{shift-args}.

make-doc script? -- flag  )

make-doc shift-args --  ) gforth
@code{1 arg} is deleted, shifting all following OS command line
parameters to the left by 1, and reducing @code{argc @@}.  This word
can change @code{argv @@}.

make-doc next-arg -- addr u  ) gforth
get the next argument from the OS command line, consuming it; if
there is no argument left, return @code{0 0}.

make-doc os-execute-parsing ... addr u xt -- ...  )

make-doc args-required1 addr u --  )

make-doc args-required i*x addr u -- i*x  ) gforth

make-doc args-evaluate i*x addr u -- j*x  ) gforth

make-doc process-option addr u --  )

make-doc (process-args) --  )

make-doc os-boot path n **argv argc --  )

make-doc w/o -- fam  ) file	w-o

make-doc r/w -- fam  ) file	r-w

make-doc r/o -- fam  ) file	r-o

make-doc bin fam1 -- fam2  ) file

make-doc write-line c-addr u fileid -- ior  ) file

make-doc ( compilation 'ccc<close-paren>' -- ; run-time --  ) core,file	paren

make-doc path-allot umax --  ) gforth
@code{Allot} a path with @i{umax} characters capacity, initially empty.

make-doc +place adr len adr  )

make-doc fpath -- path-addr  ) gforth

make-doc make-path -- addr  )

make-doc os-cold --  )

make-doc also-path c-addr len path-addr --  ) gforth
add the directory @i{c-addr len} to @i{path-addr}.

make-doc clear-path path-addr --  ) gforth
Set the path @i{path-addr} to empty.

make-doc only-path adr len path^ --  )

make-doc path+ path-addr  "dir" --  ) gforth
Add the directory @var{dir} to the search path @var{path-addr}.

make-doc fpath+ "dir"  ) gforth
Add directory @var{dir} to the Forth search path.

make-doc path= path-addr "dir1|dir2|dir3"  ) gforth
Make a complete new search path; the path separator is |.

make-doc fpath= "dir1|dir2|dir3"  ) gforth
Make a complete new Forth search path; the path separator is |.

make-doc path>string path -- c-addr u  )

make-doc next-path addr u -- addr1 u1 addr2 u2  )

make-doc previous-path path^ --  )

make-doc .path path-addr --  ) gforth
Display the contents of the search path @var{path-addr}.

make-doc .fpath --  ) gforth
Display the contents of the Forth search path.

make-doc absolut-path? addr u -- flag  ) gforth
A path is absolute if it starts with a / or a ~ (~ expansion),
or if it is in the form ./*, extended regexp: ^[/~]|./, or if
it has a colon as second character ("C:...").  Paths simply
containing a / are not absolute!

make-doc ofile )

make-doc tfile )

make-doc pathsep? )

make-doc need/ )

make-doc extractpath adr len -- adr len2  )

make-doc remove~+ --  )

make-doc expandtopic --  ) stack effect correct? - anton

make-doc del-string addr u u1 -- addr u2  )

make-doc del-./s addr u -- addr u2  )

make-doc preserve-root addr1 u1 -- addr2 u2  )

make-doc skip-..-prefixes addr1 u1 -- addr2 u2  )

make-doc compact-filename addr u1 -- addr u2  )

make-doc reworkdir --  )

make-doc open-ofile -- fid ior  )
opens the file whose name is in ofile

make-doc check-path adr1 len1 adr2 len2 -- fid 0 | 0 ior  )

make-doc open-path-file addr1 u1 path-addr -- wfileid addr2 u2 0 | ior  ) gforth
Look in path @var{path-addr} for the file specified by @var{addr1
u1}.  If found, the resulting path and and (read-only) open file
descriptor are returned. If the file is not found, @var{ior} is
what came back from the last attempt at opening the file (in the
current implementation).

make-doc open-fpath-file addr1 u1 -- wfileid addr2 u2 0 | ior  ) gforth
Look in the Forth search path for the file specified by @var{addr1 u1}.
If found, the resulting path and an open file descriptor
are returned. If the file is not found, @var{ior} is non-zero.

make-doc included-files pointer to and count of included files  )

make-doc image-included-files pointer to and count of included files  )

make-doc sourcefilename -- c-addr u  ) gforth
The name of the source file which is currently the input
source.  The result is valid only while the file is being
loaded.  If the current input source is no (stream) file, the
result is undefined.  In Gforth, the result is valid during the
whole seesion (but not across @code{savesystem} etc.).

make-doc sourceline# -- u  ) gforth		sourceline-number
The line number of the line that is currently being interpreted
from a (stream) file. The first line has the number 1. If the
current input source is not a (stream) file, the result is
undefined.

make-doc init-included-files --  ) gforth-internal

make-doc included? c-addr u -- f  ) gforth
True only if the file @var{c-addr u} is in the list of earlier
included files. If the file has been loaded, it may have been
specified as, say, @file{foo.fs} and found somewhere on the
Forth search path. To return @code{true} from @code{included?},
you must specify the exact path to the file, even if that is
@file{./foo.fs}

make-doc add-included-file c-addr u --  ) gforth
add name c-addr u to included-files

make-doc included1 i*x file-id c-addr u -- j*x  ) gforth
Include the file file-id with the name given by @var{c-addr u}.

make-doc included i*x c-addr u -- j*x  ) file
@code{include-file} the file whose name is given by the string
@var{c-addr u}.

make-doc required i*x addr u -- i*x  ) gforth
@code{include-file} the file with the name given by @var{addr
u}, if it is not @code{included} (or @code{required})
already. Currently this works by comparing the name of the file
(with path) against the names of earlier included files.

make-doc include ... "file" -- ...  ) gforth
@code{include-file} the file @var{file}.

make-doc require ... "file" -- ...  ) gforth
@code{include-file} @var{file} only if it is not included already.

make-doc .strings addr u --  ) gforth
list the strings from an array of string descriptors at addr
with u entries, one per line.

make-doc .included --  ) gforth
list the names of the files that have been @code{included}

make-doc locals-list )

make-doc dead-code )

make-doc backedge-locals )

make-doc UNREACHABLE --  ) gforth

make-doc ASSUME-LIVE orig -- orig  ) gforth

make-doc live-orig )

make-doc dead-orig )

make-doc dest )

make-doc do-dest )

make-doc scopestart )

make-doc def? n --  )

make-doc orig? n --  )

make-doc dest? n --  )

make-doc do-dest? n --  )

make-doc scope? n --  )

make-doc non-orig? n --  )

make-doc cs-item? n --  )

make-doc cs-item-size )

make-doc CS-PICK ... u -- ... destu  ) tools-ext c-s-pick

make-doc CS-ROLL destu/origu .. dest0/orig0 u -- .. dest0/orig0 destu/origu  ) tools-ext c-s-roll

make-doc cs-push-part -- list addr  )

make-doc cs-push-orig -- orig  )

make-doc other-control-flow --  )

make-doc ?struc flag --  )

make-doc sys? sys --  )

make-doc >mark -- orig  )

make-doc >resolve addr --  )

make-doc <resolve addr --  )

make-doc BUT )

make-doc YET )

make-doc AHEAD compilation -- orig ; run-time --  ) tools-ext

make-doc IF compilation -- orig ; run-time f --  ) core

make-doc ?DUP-IF compilation -- orig ; run-time n -- n|  ) gforth	question-dupe-if
This is the preferred alternative to the idiom "@code{?DUP IF}", since it can be
better handled by tools like stack checkers. Besides, it's faster.

make-doc ?DUP-0=-IF compilation -- orig ; run-time n -- n|  ) gforth	question-dupe-zero-equals-if

make-doc then-like orig --  )

make-doc cs>addr orig/dest --  )

make-doc THEN compilation orig -- ; run-time --  ) core

make-doc ENDIF compilation orig -- ; run-time --  ) gforth

make-doc ELSE compilation orig1 -- orig2 ; run-time --  ) core

make-doc begin-like --  )

make-doc BEGIN compilation -- dest ; run-time --  ) core

make-doc again-like dest -- addr  )

make-doc AGAIN compilation dest -- ; run-time --  ) core-ext

make-doc until-like list addr xt1 xt2 --  )

make-doc UNTIL compilation dest -- ; run-time f --  ) core

make-doc WHILE compilation dest -- orig dest ; run-time f --  ) core

make-doc REPEAT compilation orig dest -- ; run-time --  ) core

make-doc leave-stack-size )

make-doc leave-stack )

make-doc leave-sp )

make-doc clear-leave-stack --  )

make-doc >leave orig --  )

make-doc leave> -- orig  )

make-doc DONE compilation orig -- ; run-time --  ) gforth

make-doc LEAVE compilation -- ; run-time loop-sys --  ) core

make-doc ?LEAVE compilation -- ; run-time f | f loop-sys --  ) gforth	question-leave

make-doc DO compilation -- do-sys ; run-time w1 w2 -- loop-sys  ) core

make-doc ?do-like -- do-sys  )

make-doc ?DO compilation -- do-sys ; run-time w1 w2 -- | loop-sys  ) core-ext	question-do

make-doc +DO compilation -- do-sys ; run-time n1 n2 -- | loop-sys  ) gforth	plus-do

make-doc U+DO compilation -- do-sys ; run-time u1 u2 -- | loop-sys  ) gforth	u-plus-do

make-doc -DO compilation -- do-sys ; run-time n1 n2 -- | loop-sys  ) gforth	minus-do

make-doc U-DO compilation -- do-sys ; run-time u1 u2 -- | loop-sys  ) gforth	u-minus-do

make-doc FOR compilation -- do-sys ; run-time u -- loop-sys  ) gforth

make-doc loop-like do-sys xt1 xt2 --  )

make-doc LOOP compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2  ) core

make-doc +LOOP compilation do-sys -- ; run-time loop-sys1 n -- | loop-sys2  ) core	plus-loop

make-doc -LOOP compilation do-sys -- ; run-time loop-sys1 u -- | loop-sys2  ) gforth	minus-loop

make-doc S+LOOP compilation do-sys -- ; run-time loop-sys1 n -- | loop-sys2  ) gforth	s-plus-loop

make-doc NEXT compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2  ) gforth

make-doc exit-like --  )

make-doc EXIT compilation -- ; run-time nest-sys --  ) core
Return to the calling definition; usually used as a way of
forcing an early return from a definition. Before
@code{EXIT}ing you must clean up the return stack and
@code{UNLOOP} any outstanding @code{?DO}...@code{LOOP}s.

make-doc ?EXIT --  ) gforth

make-doc CLiteral Compilation c-addr1 u ; run-time -- c-addr  )

make-doc SLiteral Compilation c-addr1 u ; run-time -- c-addr2 u  ) string
Compilation: compile the string specified by @i{c-addr1},
@i{u} into the current definition. Run-time: return
@i{c-addr2 u} describing the address and length of the
string.

make-doc ABORT" compilation 'ccc"' -- ; run-time f --  ) core,exception-ext	abort-quote
If any bit of @i{f} is non-zero, perform the function of @code{-2 throw},
displaying the string @i{ccc} if there is no exception frame on the
exception stack.

make-doc S" compilation 'ccc"' -- ; run-time -- c-addr u  ) core,file	s-quote
Compilation: Parse a string @i{ccc} delimited by a @code{"}
(double quote). At run-time, return the length, @i{u}, and the
start address, @i{c-addr} of the string. Interpretation: parse
the string as before, and return @i{c-addr}, @i{u}. Gforth
@code{allocate}s the string. The resulting memory leak is usually
not a problem; the exception is if you create strings containing
@code{S"} and @code{evaluate} them; then the leak is not bounded
by the size of the interpreted files and you may want to
@code{free} the strings.  ANS Forth only guarantees one buffer of
80 characters, so in standard programs you should assume that the
string lives only until the next @code{s"}.

make-doc ." compilation 'ccc"' -- ; run-time --  ) core	dot-quote
Compilation: Parse a string @i{ccc} delimited by a " (double
quote). At run-time, display the string. Interpretation semantics
for this word are undefined in ANS Forth. Gforth's interpretation
semantics are to display the string. This is the simplest way to
display a string from within a definition; see examples below.

make-doc countif )

make-doc dummy )

make-doc >exec :- )

make-doc scanIF )

make-doc [struct]-searchreveal )

make-doc [struct]-voc )

make-doc ?if )

make-doc [IF] )

make-doc [THEN] )

make-doc [ELSE] )

make-doc [IFDEF] )

make-doc [IFUNDEF] )

make-doc [ENDIF] )

make-doc [BEGIN] )

make-doc [WHILE] )

make-doc [UNTIL] )

make-doc [AGAIN] )

make-doc [DO] )

make-doc [?DO] )

make-doc [LOOP] )

make-doc [+LOOP] )

make-doc [REPEAT] )

make-doc [defined] "<spaces>name" -- flag  )
returns true if name is found in current search order

make-doc defined )

make-doc [undefined] "<spaces>name" -- flag  )
returns false if name is found in current search order

make-doc [IF] flag --  ) tools-ext bracket-if
If flag is @code{TRUE} do nothing (and therefore
execute subsequent words as normal). If flag is @code{FALSE},
parse and discard words from the parse
area (refilling it if necessary using
@code{REFILL}) including nested instances of @code{[IF]}..
@code{[ELSE]}.. @code{[THEN]} and @code{[IF]}.. @code{[THEN]}
until the balancing @code{[ELSE]} or @code{[THEN]} has been
parsed and discarded. Immediate word.

make-doc [IFDEF] "<spaces>name" --  ) gforth bracket-if-def
If name is found in the current search-order, behave like
@code{[IF]} with a @code{TRUE} flag, otherwise behave like
@code{[IF]} with a @code{FALSE} flag. Immediate word.

make-doc [IFUNDEF] "<spaces>name" --  ) gforth bracket-if-un-def
If name is not found in the current search-order, behave like
@code{[IF]} with a @code{TRUE} flag, otherwise behave like
@code{[IF]} with a @code{FALSE} flag. Immediate word.

make-doc [ELSE] --  ) tools-ext bracket-else
Parse and discard words from the parse
area (refilling it if necessary using
@code{REFILL}) including nested instances of @code{[IF]}..
@code{[ELSE]}.. @code{[THEN]} and @code{[IF]}.. @code{[THEN]}
until the balancing @code{[THEN]} has been parsed and discarded.
@code{[ELSE]} only gets executed if the balancing @code{[IF]}
was @code{TRUE}; if it was @code{FALSE}, @code{[IF]} would
have parsed and discarded the @code{[ELSE]}, leaving the
subsequent words to be executed as normal.
Immediate word.

make-doc [THEN] --  ) tools-ext bracket-then
Do nothing; used as a marker for other words to parse
and discard up to. Immediate word.

make-doc [ENDIF] --  ) gforth bracket-end-if
Do nothing; synonym for @code{[THEN]}

make-doc (i) )

make-doc [DO] n-limit n-index --  ) gforth bracket-do

make-doc [?DO] n-limit n-index --  ) gforth bracket-question-do

make-doc [+LOOP] n --  ) gforth bracket-question-plus-loop

make-doc [LOOP] --  ) gforth bracket-loop

make-doc [FOR] n --  ) gforth bracket-for

make-doc [NEXT] n --  ) gforth bracket-next

make-doc [I] -- n  ) gforth bracket-i

make-doc [BEGIN] --  ) gforth bracket-begin

make-doc [UNTIL] flag --  ) gforth bracket-until

make-doc [REPEAT] --  ) gforth bracket-repeat

make-doc [AGAIN] --  ) gforth bracket-again

make-doc [WHILE] flag --  ) gforth bracket-while

make-doc maxdepth-.s -- addr  ) gforth maxdepth-dot-s
A variable containing 9 by default.  @code{.s} and @code{f.s}
display at most that many stack items.

make-doc .s --  ) tools dot-s
Display the number of items on the data stack, followed by a list
of the items (but not more than specified by @code{maxdepth-.s};
TOS is the right-most item.

make-doc /dump )

make-doc .4 addr -- addr'  )

make-doc .chars addr --  )

make-doc .line addr --  )

make-doc dump addr u --  ) tools dump
Display @var{u} lines of memory starting at address @var{addr}. Each line
displays the contents of 16 bytes. When Gforth is running under
an operating system you may get @file{Invalid memory address} errors
if you attempt to access arbitrary locations.

make-doc ? a-addr --  ) tools question
Display the contents of address @var{a-addr} in the current number base.

make-doc rows -- u  )

make-doc cols -- u  )

make-doc wordlist-words wid --  ) gforth
Display the contents of the wordlist wid.

make-doc words )
** this will not get annotated. See other defn in search.fs .. **
It does not work to use "wordset-" prefix since this file is glossed
by cross.fs which doesn't have the same functionalty as makedoc.fs

make-doc vlist --  ) gforth
Old (pre-Forth-83) name for @code{WORDS}.

make-doc docon: -- addr  ) gforth
The code address of a @code{CONSTANT}.

make-doc dovalue: -- addr  ) gforth
The code address of a @code{CONSTANT}.

make-doc docol: -- addr  ) gforth
The code address of a colon definition.

make-doc dovar: -- addr  ) gforth
The code address of a @code{CREATE}d word.

make-doc douser: -- addr  ) gforth
The code address of a @code{USER} variable.

make-doc dodefer: -- addr  ) gforth
The code address of a @code{defer}ed word.

make-doc dofield: -- addr  ) gforth
The code address of a @code{field}.

make-doc dodoes: -- addr  ) gforth
The code address of a @code{field}???
